<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Little Developer&#39;s Diary</title>
  
  <subtitle>A record of my learning &amp; trying!</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://vleudive.github.io/"/>
  <updated>2018-02-07T14:18:13.624Z</updated>
  <id>https://vleudive.github.io/</id>
  
  <author>
    <name>VleuDive</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blockly 사용법 7. 웹에서 Blockly 사용하기</title>
    <link href="https://vleudive.github.io/2018/01/25/7_Blockly_on_web/"/>
    <id>https://vleudive.github.io/2018/01/25/7_Blockly_on_web/</id>
    <published>2018-01-25T08:10:10.000Z</published>
    <updated>2018-02-07T14:18:13.624Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_7.png" alt=""></p><h1 id="웹에서-Blockly-사용하기"><a href="#웹에서-Blockly-사용하기" class="headerlink" title="웹에서 Blockly 사용하기"></a>웹에서 Blockly 사용하기</h1><p>Blockly는 웹, Android, iOS에서 모두 사용 가능하지만, 여기서는 웹 환경을 기준으로 하겠습니다. </p><p>Blockly로 만든 블록과 editor(Workspace)를 웹에서 사용하기 위해서는 다음과 같은 단계를 거칩니다.</p><ol><li>Blockly workspace를 삽입할 수 있는 웹 페이지를 준비한다.</li><li>XML 형식으로 workspace의 카테고리, 블록 구성 등을 설정한다.</li><li>완성된 workspace를 웹 페이지에 inject한다.</li><li>웹 페이지의 나머지 기능들을 구현한다.</li></ol><p>한 단계씩 따라가 보겠습니다.</p><h2 id="Blockly-Playground"><a href="#Blockly-Playground" class="headerlink" title="Blockly Playground"></a>Blockly Playground</h2><p>아래 사진은 Blockly 블록 구현과 적용을 위해 간단하게 만들어 본 Playground 페이지입니다. 전체 html 코드는 <a href="https://github.com/VleuDive/Blockly_Web-playground/blob/master/Webpages/test.html" target="_blank" rel="noopener">여기</a>에서 보실 수 있습니다. 사진에서 보시다시피, Blockly 사용에 꼭 필요한 기능만 추가해 놓았기 때문에 구조는 굉장히 단순합니다.</p><p><img src="/img/Playground_detail.png" alt="playground"></p><ol><li><p>Blockly Workspace : 실제로 블록을 놓고 조합하며 사용할 수 있는 공간입니다. 이 포스트에서는 이 부분을 구현하는 것을 중점적으로 다룹니다.</p></li><li><p>Code Area : 이 부분에는 workspace에 올라온 블록들이 변환된 실제 코드가 나타납니다. Python을 기준으로 블록들을 정의했기 때문에, 일단은 이 부분에 파이썬 코드가 나타나도록 하였습니다.</p></li><li><p>Description Area : 블록에 대한 상세 설명을 확인할 수 있는 부분을 구현했습니다. Workspace에 블록이 새로 생성되거나, 이미 생성되어 있는 블록이 클릭되었을 때 해당 블록에 대한 상세 설명이 여기에 표시됩니다.</p></li></ol><h3 id="필요한-파일-포함시키기"><a href="#필요한-파일-포함시키기" class="headerlink" title="필요한 파일 포함시키기"></a>필요한 파일 포함시키기</h3><p>웹 페이지에서 Blockly workspace를 만들기 위해서는 일단 관련 파일을 추가해 주는 구문이 필요합니다. 이 파일 추가는 HTML 파일의 <code>&lt;head&gt;</code> 구역 안에 <code>&lt;script src=&quot;파일 경로&quot;&gt;</code> 태그를 통해 추가할 수 있습니다. 정확한 코드는 다음과 같습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../blockly_compressed.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../python_compressed.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../blocks_compressed.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(원본 코드에는 더 많은 파일이 추가되어 있지만 설명에 필요하지 않은 부분은 생략했습니다.)</p><p>첫 번째로 추가하는 <strong>blockly_compressed.js</strong>는 Blockly 자체의 설정과 관련된 파일입니다. Blockly 소스 코드를 다운받으면 패키지 안에 처음부터 들어 있는 파일 중 하나입니다.</p><p>두 번째 파일인 <strong>python_compressed.js</strong> 역시 처음부터 들어 있는 파일로, Python 언어 규칙 및 블록 변환과 관련된 내용을 압축해서 담고 있습니다. Python 이외의 다른 언어를 사용하고 싶으시다면 lua_compressed, dart_compressed와 같은 다른 파일을 사용하실 수 있습니다.</p><p>주의할 점은, <strong>언어명_compressed.js 파일은 반드시 blockly_compressed.js 파일 바로 밑 줄에서 포함시켜야 한다</strong>는 것입니다. Blockly 공식 가이드에서도 강조하고 있는 점으로, 이것을 지키지 않고 언어명_compressed.js를 포함시키는 코드를 blockly_compressed.js를 포함시키는 줄과 멀리 떨어뜨려 작성하게 되면 후에 코드 생성 및 변환 시 에러가 발생합니다.</p><p>세 번째 파일인 <strong>blocks_compressed.js</strong>도 기본 파일 중 하나로, 이 파일은 미리 정의되어 있는 기본 블록에 대한 설정을 모두 담고 있습니다. 이 파일이 없으면 Blockly에서 기본으로 제공하는 블록들을 workspace에 올려 사용하는 것이 불가능해집니다.</p><h3 id="Workspace-구성하기"><a href="#Workspace-구성하기" class="headerlink" title="Workspace 구성하기"></a>Workspace 구성하기</h3><p>Blockly Workspace는 기본적으로 정해진 모양이 있지만, 그것 외에 포함시킬 블록의 종류나 블록 카테고리 등은 코드를 통해 마음대로 정해 줄 수 있습니다.</p><p>이런 Workspace 설정은 XML 형태로 하게 되는데, 예제 페이지에서는 <code>&lt;xml&gt;</code> 태그 구역에 모든 내용을 기술했습니다. 다른 XML 파일로 분리하는 것도 가능합니다.</p><p>XML로 표현한 workspace 구조는 대략 다음과 같습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span> <span class="attr">id</span>=<span class="string">"id로 사용할 이름"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">name</span>=<span class="string">"카테고리 이름"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">block</span> <span class="attr">type</span>=<span class="string">"블록 타입(이름)"</span>&gt;</span><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">block</span> <span class="attr">type</span>=<span class="string">"블록 타입(이름)"</span>&gt;</span><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">                            .</span><br><span class="line">                            .</span><br><span class="line">                            .</span><br><span class="line">    <span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 XML구조는 후에 workspace inject 함수를 호출할 때 넘겨지게 됩니다. 일종의 설정파일처럼 사용되지요. 그렇기 때문에 display 속성은 none으로 설정합니다. 이 XML 구조 자체가 변환되어 보이는 것이 아니라, inject라는 함수의 파라미터로서 전달되어, 그 함수에서 이 XML 구조를 사용해 만들어낸 workspace가 눈에 보이게 되는 것이기 때문이지요.</p><p><strong>Category</strong> 설정은 블록 여러 개를 하나의 카테고리로 묶어 더 손쉽게 관리할 수 있게 도와 줍니다. Workspace 내에서 사용하는 블록의 개수가 적을 때는 상관없지만, 개수가 많아지게 되면 어떤 블록이 있는지 한 눈에 알아보기 어렵기 때문에 카테고리를 사용해서 관리하는 것이 좋습니다. 위에 있는 Playground 페이지 스크린샷을 보면,”Basic”,”Custom”,”Project” 라는 큰 카테고리가 등록되어 있습니다.</p><p>카테고리 안에 서브 카테고리를 지정할 수도 있습니다. 이런 식으로 태그를 중첩해 사용하면 됩니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">name</span>=<span class="string">"큰 카테고리 이름"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">name</span>=<span class="string">"작은 카테고리 이름"</span>&gt;</span></span><br><span class="line">                    .</span><br><span class="line">                    .</span><br><span class="line">                    .</span><br><span class="line">    <span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그 다음 단계는 카테고리에 블록을 추가하는 것입니다. 블록 추가는 <strong>block</strong> 태그로 할 수 있습니다. 이 때, block name이 아니라 <strong>block type=</strong>형태로 블록을 지정합니다. 여기서 type에는 블록을 정의할 때 정해 준 type명이 들어갑니다.</p><h3 id="웹페이지에-Workspace-Inject하기"><a href="#웹페이지에-Workspace-Inject하기" class="headerlink" title="웹페이지에 Workspace Inject하기"></a>웹페이지에 Workspace Inject하기</h3><p>Workspace를 정의했으니 이제는 실제로 웹페이지에 workspace를 삽입할 차례입니다. 페이지에 workspace를 삽입하는 함수는 <code>&lt;script&gt;</code>태그 안에 Javascript로 정의되며, 다음과 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demoWorkspace=Blockly.inject(<span class="string">'blocklyDiv'</span>,&#123;<span class="attr">toolbox</span>:<span class="built_in">document</span>.getElementById(<span class="string">'toolbox'</span>)&#125;);</span><br></pre></td></tr></table></figure><p>여기서 <strong>demoWorkspace</strong>는 만들어 줄 workspace의 이름입니다. 후에 세이브 &amp; 로드 등의 조작을 할 때 이 이름을 가지고 workspace를 지정하게 됩니다.</p><p><strong>Blockly.Inject()</strong> 함수는 미리 정의된 workspace 설정을 가져와 웹 페이지 상에 실제로 삽입하는 함수입니다. 파라미터는 두 개를 받으며, 처음 파라미터는 workspace를 삽입할 html element의 id입니다. 여기서는 “blocklyDiv” 라는 div에 workspace를 삽입합니다. 두 번째 파라미터는 XML 설정을 가지고 오는 부분입니다. toolbox 라는 key에 XML element를 매칭해 가져오게 되지요. 여기서는 XML을 HTML 문서 내에 작성했으므로 document.getElementById() 함수를 이용해 해당 태그의 내용을 읽어 옵니다.</p><p>이 함수까지 호출하고 나면, 웹페이지에 Blockly workspace가 삽입됩니다. 이후 workspace가 원하는 위치에 제대로 삽입되었는지, 작동은 제대로 되었는지 테스트를 해 보면 웹에서의 Blockly 사용 준비는 끝납니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;웹에서-Blockly-사용하기&quot;&gt;&lt;a href=&quot;#웹에서-Blockly-사용하기&quot; class=&quot;headerlink&quot; title=&quot;웹에서 Blockly 사용하기&quot;
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
  <entry>
    <title>Blockly 사용법 6. Code generator 작성하기</title>
    <link href="https://vleudive.github.io/2018/01/25/6_code_generation/"/>
    <id>https://vleudive.github.io/2018/01/25/6_code_generation/</id>
    <published>2018-01-25T01:58:04.000Z</published>
    <updated>2018-02-07T14:13:25.607Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_6.png" alt=""></p><h1 id="Code-generation-코드-작성하기"><a href="#Code-generation-코드-작성하기" class="headerlink" title="Code generation 코드 작성하기"></a>Code generation 코드 작성하기</h1><p>지금까지 Blockly에서 custom block의 모양과 성질을 정의하였습니다. 지금까지의 단계를 모두 마쳤다면, 이제 사용자의 마음대로 정의된, 온전한 ‘형태’를 갖춘 블록이 만들어진 것입니다. 하지만, 이것만으로는 부족합니다. 지금까지 만든 블록은 아직 형태만 갖추어진 껍데기이기 때문에 실질적인 기능을 나타내지 못합니다. 블록이 실제 프로그래밍 언어로 된 코드와 연결될 수 있게 하기 위해서는 code geneartor 라는 특수한 코드를 같이 붙여 주어야 합니다. 보통 code generator는 block definition  부분과 별도의 .js파일로 분리하여 작성하게 됩니다.</p><p>Code generator는 Javascript로 정의합니다. 두 가지 방법으로 작성 가능한 블록 정의 구문과는 다르게, <strong>code generator 정의 구문은 Javascript 스타일로만 정의가 가능합니다.</strong> 또한, 블록을 변환할 언어(목표 언어)에 따라서 실제 매핑되는 구문이 달라져야 하기 때문에, 코드 작성 시 어떤 언어로 변환하는 것인지 명시해 주어야 합니다. 자세한 코드는 아래에서 살펴보겠습니다.</p><h2 id="Code-generator-정의-코드"><a href="#Code-generator-정의-코드" class="headerlink" title="Code generator 정의 코드"></a>Code generator 정의 코드</h2><p>여태까지 정의한 블록인, Short_math 블록을 가지고 계속 진행합니다.</p><p><img src="/img/short_math_ex.png" alt="short_math"></p><p>이 블록에 Python 코드를 연결시켜 보겠습니다. 이 블록과 연결해서 생성하려는 코드는 a+=b, a*=b, a/=b, a-=b 중 한 가지입니다.</p><p>전체 코드는 다음과 같이 작성합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Blockly.Python[<span class="string">'short_math'</span>]=<span class="function"><span class="keyword">function</span>(<span class="params">block</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num_1=Blockly.Python.valueToCode(block,<span class="string">'a'</span>,Blockly.Python.ORDER_ATOMIC);</span><br><span class="line">    <span class="keyword">var</span> dropdown_select = block.getFieldValue(<span class="string">'select'</span>);</span><br><span class="line">    <span class="keyword">var</span> num_2=Blockly.Python.valueToCode(block,<span class="string">'b'</span>,Blockly.Python.ORDER_ATOMIC);</span><br><span class="line">    <span class="keyword">var</span> code=num_1+dropdown_select+<span class="string">"= "</span>+num_2+<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 자세히 분석해 보면 다음과 같습니다.</p><h3 id="Code-generation-시작-함수"><a href="#Code-generation-시작-함수" class="headerlink" title="Code generation 시작 함수"></a>Code generation 시작 함수</h3><p>코드는 전반적으로 이렇게 구성되어 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Blockly.Python[<span class="string">'short_math'</span>]=<span class="function"><span class="keyword">function</span>(<span class="params">block</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//함수 내용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Blockly.Python[‘short_math’]</strong> 부분은 “Short_math 블록에 Python으로 된 코드를 붙일 것이다” 라고 해석할 수 있습니다. 여기서 short_math는 이미 정의해 놓은 Short_math 블록의 type을 가리킵니다. 이 구조 자체는 Javascript 스타일로 블록을 정의할 때와 매우 유사하지만, 한 가지 다른 점이 있다면 시작 부분이 <strong>Blockly.Blocks 가 아니라 Blockly.Python</strong>이라는 것입니다. 바로 이 .Python 부분에서 블록을 어떤 언어로 변환한 것인지를 지정합니다. Python 이외의 다른 언어로의 변환을 하고 싶다면, 시작 부분을 다음과 같이 써 주시면 됩니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Blockly.Lua <span class="comment">// Lua로 변환</span></span><br><span class="line">Blockly.Javascript <span class="comment">// Javascript로 변환</span></span><br><span class="line">Blockly.Dart <span class="comment">// Dart로 변환</span></span><br><span class="line">Blockly.PHP <span class="comment">// PHP로 변환</span></span><br></pre></td></tr></table></figure><p>이후 <strong>function(block)</strong> 부분에서 block을 파라미터로 받는 함수를 선언하고, 그 함수 안에 code generation의 단계가 기술됩니다.</p><h3 id="Block으로부터-값-읽어-오기"><a href="#Block으로부터-값-읽어-오기" class="headerlink" title="Block으로부터 값 읽어 오기"></a>Block으로부터 값 읽어 오기</h3><p>Short_math 블록에는 읽어 와야 할 값이 총 3가지 있습니다.</p><ol><li>첫 번째 value input(첫 번째 피연산자)의 값</li><li>Dropdown field에서 선택된 option값 (연산의 종류)</li><li>두 번째 value input(두 번째 피연산자)의 값</li></ol><p>이 값들을 Blockly에서는 이런 식으로 읽어 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num_1=Blockly.Python.valueToCode(block,<span class="string">'a'</span>,Blockly.Python.ORDER_ATOMIC);</span><br><span class="line"><span class="keyword">var</span> dropdown_select = block.getFieldValue(<span class="string">'select'</span>);</span><br><span class="line"><span class="keyword">var</span> num_2=Blockly.Python.valueToCode(block,<span class="string">'b'</span>,Blockly.Python.ORDER_ATOMIC);</span><br></pre></td></tr></table></figure><p>첫 번째 줄은 첫 번째 value input을 읽어 오는 코드입니다. <strong>Blockly.Python.valueToCode()</strong>함수를 사용해 값을 읽어 오고 있습니다. (Python 이외의 다른 언어를 사용하려면 .Python부분을 다른 언어로 바꾸어 주시면 됩니다.) Blockly에서 블록에 할당된 input이나 field의 값을 읽어 올 때는 이처럼 미리 지정된 함수를 사용하는데, 값 읽기에 사용되는 함수 몇 가지를 간단히 정리하면 다음과 같습니다.</p><ul><li><p>valueToCode() : Value input의 값을 읽습니다. 파라미터는 3개이며, 순서대로 해당 input이 위치하는 블록, input의 이름, 그리고 그 값이 속하는 타입의 연산자 우선순위입니다. 연산자 우선순위에 대해서는 뒤에 다시 정리하겠습니다.</p></li><li><p>statementToCode() : Statement input의 값을 읽습니다. 파라미터는 2개이며, 순서대로 해당 input이 위치하는 블록과 input의 이름을 의미합니다.</p></li><li><p>block.getFieldValue() : 블록에 단일 Field가 있는 경우, 이 field의 값을 읽어 오는 함수입니다. 특이하게도 이 함수는 위의 두 함수와 다르게 독립적으로 호출되지 않고 block의 하위 메소드로 호출됩니다. 그렇기 때문에 어떤 블록의 field를 읽어 오는 것인지 명시해 줄 필요가 없고, 읽어 오려는 field의 이름만 파라미터로 넘겨 주면 됩니다.</p></li></ul><p>이번 예시에서는 2개의 input과 1개의 dropdown field가 존재하기 때문에 valueToCode()와 block.getFieldValue() 함수만 사용되었습니다. 첫 번째 줄에서는 block의 “a” input 값을 읽어 오고, 두 번째 줄에서는 block의 select field의 선택 값을 가져오며 마지막 줄에서는 block의 “b” input의 값을 읽어 옵니다.</p><h3 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h3><p>valueToCode() 함수는 세 번째 파라미터로 <strong>연산자 우선순위</strong>를 받습니다. 연산자 우선순위는 코드를 생성하고 조합하는 과정에서 꽤 중요한 역할을 하는데요, Blockly/generators/(언어명).js 파일 안에 각 언어별 연산자 우선순위가 지정되어 있습니다. 미리 지정되어 있는 값이기 때문에 사용할 때는 그 값을 고민할 필요 없이, 미리 지정되어 있는 해당 연산자의 이름만 호출해서 사용 가능합니다.</p><p>하지만 조금 이상한 것은, valueToCode()가 가져오는 것은 보통 Number나 String 등의 값일 텐데, 이런 단일 값을 가져올 때에도 우선순위를 명시해 주어야 하는가 하는 점입니다. 결론부터 말하면 “예”입니다. 이 연산자 우선순위는 나중에 코드를 생성하고 조합하는 과정에서 필요한 부분을 괄호로 묶어 주는 등의 작업을 하는 데 필요합니다. 지금 다루고 있는 블록에 어떤 input이 결합하느냐에 따라 최종 코드가 어떤 모양이 될 지가 결정되며, 어떤 부분이 괄호로 묶일지 하는 점도 달라집니다. 이런 점을 사람이 하나하나 하드코딩해 줄 수 없기 때문에, Blockly는 연산자 우선순위를 이용해 코드의 형태를 결정하는 방식을 취하고 있습니다. 그렇게 하기 위해서는 숫자 하나, 문자열 하나에도 모두 우선순위를 부여해서 Blockly가 다루는 모든 타입의 결합 형태를 파악할 필요가 있습니다.  </p><p>Python 기준으로 자주 쓰이는 연산자 우선순위에는 다음과 같은 것들이 있습니다.</p><ul><li><p>ORDER_ATOMIC : 숫자나 String 등 하나의 독립적 값을 의미합니다.</p></li><li><p>ORDER_COLLECTION : 리스트나 튜플 등 여러 개의 요소가 하나의 큰 덩어리를 이루는 형태의 자료구조를 의미합니다.</p></li><li><p>ORDER_NONE : 정의되어 있는 어떤 연산자에도 해당되지 않는 것을 리턴하는 경우나 리턴값이 없는 경우 등에 사용합니다.</p></li></ul><h3 id="코드-생성"><a href="#코드-생성" class="headerlink" title="코드 생성"></a>코드 생성</h3><p>예시 코드의 마지막 두 줄은 이렇게 끝납니다. 이 부분이 실제 Python code를 생성해서 string으로 리턴해 주는 부분이죠.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> code=num_1+dropdown_select+<span class="string">"= "</span>+num_2+<span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span> code;</span><br></pre></td></tr></table></figure><p>첫 번째 줄을 리턴한 code를 생성하는 부분입니다. 앞에서 읽어 온 다양한 값들과 파이썬 구문의 일부를 조합하여 하나의 완전한 코드를 만들어 내고 있습니다. 만약 num_1에 “a”, dropdown_select에 “+”, num_2에 “5”가 들어왔다면 완성되는 코드는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a+=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>그 다음 줄에서는 만들어진 code를 리턴하고 있습니다. 이때 주의하실 점은, <strong>output이 있는 블록과 없는 블록은 code를 리턴하는 방식이 서로 다르다</strong>는 것입니다. Short_math는 output이 없는 블록이므로, 단순히 code 한 줄만 리턴합니다. 이런 식으로 output이 없는 블록은 코드만 리턴해야 합니다. </p><p>하지만 output이 있는 블록의 경우, 다음과 같이 code와 연산자 우선순위를 같이 리턴해 주어야 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [code, Blockly.Python.ORDER_ATOMIC];</span><br></pre></td></tr></table></figure><p>output이 있는 블록의 경우 실행 결과 리턴되는 값이 있다는 뜻이기 때문에, 그 리턴 값에 대한 우선순위를 같이 명시해 주어야 합니다. 만약 리턴하는 값이 이미 정의된 연산자 범주 안에 속하지 않거나, 블록 모양상으로만 output이 존재하고 실제로는 리턴값이 없는 경우라면 ORDER_ATOMIC 대신 ORDER_NONE을 리턴할 수 있습니다.</p><p>이 과정까지 모두 끝내면 모양과 기능을 동시에 갖춘 온전한 블록이 만들어집니다. 이제 남은 것은 만든 블록을 Blockly editor에 등록하는 것입니다. 그 점에 대해서는 다음 포스트에서 다루겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Code-generation-코드-작성하기&quot;&gt;&lt;a href=&quot;#Code-generation-코드-작성하기&quot; class=&quot;headerlink&quot; title=&quot;Cod
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
  <entry>
    <title>Blockly 사용법 5. JSON array 스타일로 블록 정의하기</title>
    <link href="https://vleudive.github.io/2018/01/24/5_JSON_define_block/"/>
    <id>https://vleudive.github.io/2018/01/24/5_JSON_define_block/</id>
    <published>2018-01-24T04:55:13.000Z</published>
    <updated>2018-02-07T14:07:18.641Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_5.png" alt=""></p><h1 id="JSON-array-스타일로-블록-정의하기"><a href="#JSON-array-스타일로-블록-정의하기" class="headerlink" title="JSON array 스타일로 블록 정의하기"></a>JSON array 스타일로 블록 정의하기</h1><p><a href="https://vleudive.github.io/2018/01/24/javascript-define-block/">지난 포스트</a>에서는 처음부터 끝까지 Javascript 스타일로 블록을 정의하는 방법을 살펴보았습니다. 이번 포스트에서는 블록을 정의하는 또 다른 방법인 <strong>JSON array를 사용하는 방법</strong> 을 다루겠습니다. 이 방법은 Google Blockly 공식 가이드에서도 더 권장하는 방법이고, 익숙해진다면 Javascript만 사용한 스타일에 비해 훨씬 보기 좋고 이해하기가 쉽습니다. 또한 JSON이 널리 이용되는 데이터 표준 중 하나이기 때문에, 표준과의 호환성을 생각하면 이 방법을 사용하는 것이 더 낫습니다.</p><h2 id="정의할-블록"><a href="#정의할-블록" class="headerlink" title="정의할 블록"></a>정의할 블록</h2><p><img src="/img/short_math_ex.png" alt="short_math"></p><p>정의할 블록은 지난 포스트와 같은 <strong>Short_math</strong> 블록입니다. 지난 포스트에서 Javascript 스타일로 정의한 것과 역할도, 모양도 모두 같으며, 블록을 정의하는 방식만 살짝 달라집니다.</p><h2 id="블록-정의-코드"><a href="#블록-정의-코드" class="headerlink" title="블록 정의 코드 "></a>블록 정의 코드 </h2><p>JSON array를 사용하여 Short_math를 정의하는 코드는 다음과 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Blockly.defineBlocksWithJsonArray(</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"short_math"</span>,</span><br><span class="line">        <span class="string">"message0"</span>: <span class="string">"%1 %2 = %3 %4"</span>,</span><br><span class="line">        <span class="string">"args0"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"input_value"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"a"</span>,</span><br><span class="line">                <span class="string">"check"</span>: <span class="string">"Number"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"field_dropdown"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"select"</span>,</span><br><span class="line">                <span class="string">"options"</span>: [</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">"+"</span>,</span><br><span class="line">                        <span class="string">"+"</span></span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">"*"</span>,</span><br><span class="line">                        <span class="string">"*"</span></span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">"-"</span>,</span><br><span class="line">                        <span class="string">"-"</span></span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        <span class="string">"/"</span>,</span><br><span class="line">                        <span class="string">"/"</span></span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"input_dummy"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"input_value"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"b"</span>,</span><br><span class="line">                <span class="string">"check"</span>: <span class="string">"Number"</span></span><br><span class="line">            &#125;],</span><br><span class="line">        <span class="string">"inputsInline"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"nextStatement"</span>:<span class="literal">null</span>,</span><br><span class="line">        <span class="string">"previousStatement"</span>:<span class="literal">null</span>,</span><br><span class="line">        <span class="string">"colour"</span>: <span class="number">260</span>,</span><br><span class="line">        <span class="string">"tooltip"</span>: <span class="string">"Short version of arithmetic calculations"</span>,</span><br><span class="line">        <span class="string">"helpUrl"</span>: <span class="string">""</span></span><br><span class="line">       &#125;,</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>코드를 하나하나 분석해 보겠습니다.</p><h3 id="Block-정의-함수"><a href="#Block-정의-함수" class="headerlink" title="Block 정의 함수"></a>Block 정의 함수</h3><p>Block 정의 함수는 다음과 같은 형태를 하고 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blockly.defineBlocksWithJsonArray( <span class="comment">/*JSON array*/</span>);</span><br></pre></td></tr></table></figure><p>Javascript 형태로 정의할 때보다 매우 간단해진 것을 볼 수 있습니다. 이 함수가 받는 파라미터의 형태는 JSON array이며, 이 array 안에 얼마든지 많은 블록을 정의할 수 있습니다. 그렇기 때문에 이 함수는 전체 파일 내에서 한 번만 호출해도 되며, 한 번의 호출로 여러 블록을 정의할 수 있습니다. 주의하실 점은, JSON array 형태로 블록을 정의한다고 해서 <strong>파일 내에 JSON array만 달랑 정의하거나, 블록 정의 파일 자체를 .json 파일로 만들면 안 된다</strong>는 것입니다. 블록 정의 파일은 .js 파일이 되어야 하며, JSON array를 활용하는 정의 방식에서도 이 함수를 이용해 블록의 정의가 담겨 있는 JSON array를 받는 식으로 블록 정의를 해야 합니다. 그렇게 하지 않으면 새로운 block이 전혀 인식되지 못합니다.</p><h3 id="JSON-array의-형태"><a href="#JSON-array의-형태" class="headerlink" title="JSON array의 형태"></a>JSON array의 형태</h3><p>JSON은 기본적으로 중괄호 { } 안에 “key”:”value” 쌍의 연속으로 하나의 객체를 정의합니다.</p><p>JSON array는 이런 JSON 객체가 여러 개 모인 것으로, [] 으로 표현합니다.</p><p>위 코드의 Blockly.defineBlocksWithJsonArray() 함수의 파라미터는 언뜻 보면 매우 길어 보이지만 실제로는 다음과 같은 구조를 하고 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"블록 1의 속성 1"</span>: <span class="string">"블록 1의 값 1"</span>,</span><br><span class="line">    <span class="attr">"블록 1의 속성 2"</span>: <span class="string">"블록 1의 값 2"</span>,</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"블록 2의 속성 1"</span>: <span class="string">"블록 2의 값 1"</span>,</span><br><span class="line">    <span class="attr">"블록 2의 속성 2"</span>: <span class="string">"블록 2의 값 2"</span>,</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">  &#125;,</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>즉 배열 안의 객체(중괄호로 묶인 범위) 하나가 블록 하나를 나타낸다고 할 수 있습니다. </p><h3 id="Type과-Message"><a href="#Type과-Message" class="headerlink" title="Type과 Message"></a>Type과 Message</h3><p>JSON array는 다음과 같이 시작합니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"type": "short_math",</span><br><span class="line">"message0": "%1 %2 = %3 %4",</span><br></pre></td></tr></table></figure><p><strong>type</strong>은 <strong>블록의 이름</strong>입니다. 뒤에 XML 구문 수정을 통해 workspace에 블록을 추가할 때 이 type을 사용하게 됩니다. Javascript 스타일로 정의했을 때는 Blockly.Blocks[“short_math”] 처럼 대괄호 속에 이 이름이 들어가 있었습니다. JSON array 방식의 경우 같은 요소를 “type”이라는 이름으로 정의합니다. Type이라는 영단어의 뜻 때문에 헷갈릴 수 있으니 주의하세요.</p><p><strong>message0</strong>에는 해당 블록에 표시될 string을 지정합니다. 여기에 지정된 string의 형식이 사용자가 블록을 구분할 때 쓸 블록 라벨입니다. message’0’ 이라고 숫자가 붙어 있는 것은, 필요에 따라 message1, message2 등으로 여러 개의 message를 동시에 정의할 수도 있기 때문입니다. </p><p>message0에 지정되는 string은 %1, %2 와 같은 표기를 통해 input 또는 field 등이 들어갈 자리를 확보하고 있다는 것도 특징입니다. 이 key 바로 아래에 정의될 “args0” 배열에 들어 있는 input이 위에서부터 순서대로 %1, %2,… 위치에 들어간다고 할 수 있습니다. Javascript 방식에서 label을 붙일 때는 반드시 dummy input을 만든 뒤 dummy input의 field로 해당 label을  추가해 주는 방법을 쓰는 반면, JSON의 경우 저런 식으로 %로 표시된 자리 사이에 오는 string은 모두 label 취급이기 때문에 label의 정의가 더욱 쉽습니다. 물론, 저렇게 쓰지 않고 %로 표시된 자리에 label field를 할당해 주는 방법도 사용할 수 있습니다. </p><p>주의하실 점은, <strong>%로 표시된 자리의 개수와 실제 input의 개수가 맞지 않으면 에러가 발생한다</strong>는 것입니다. Message0에 %3번까지 자리를 지정해 놓았다면 input도 반드시 3개가 정의되어야 합니다.</p><h3 id="Input-정의"><a href="#Input-정의" class="headerlink" title="Input 정의"></a>Input 정의</h3><p>그 다음부터는 이 블록에 들어갈 input을 차례대로 정의해 줍니다. Input도 하나의 JSON array 안에 묶어서 받는데, 그 형태는 이렇습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"input 1의 속성 1"</span>: <span class="string">"input 1의 값 1"</span>,</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"input 2의 속성 1"</span>: <span class="string">"input 2의 값 1"</span>,</span><br><span class="line">    <span class="attr">"input 2의 속성 2"</span>: <span class="string">"input 2의 값 2"</span>,</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">                      .</span><br><span class="line">  &#125;,</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>이 배열은 “args0”이라는 키에 할당됩니다. Input 목록 자체를 배열로 만들어서 할당하기 때문에, input 여러 개를 정의하더라도 Javascript 형식으로 정의할 때에 비해 더 간결하고 가독성이 좋아집니다.</p><p>이제 각 input 객체를 하나하나 분석해 보겠습니다.</p><p>첫 번째 input은 이렇게 정의되어 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"input_value"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"check"</span>: <span class="string">"Number"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 <strong>type</strong>은 문자 그대로 이 input의 ‘종류’를 나타내고 있습니다. <strong>블록 정의 맨 위에 쓰이는, 블록 이름을 나타내는 type과는 그 의미가 다릅니다.</strong> 오히려 이쪽이 type이라는 단어의 원래 뜻에 가깝게 쓰이고 있지요. 이 type에는 input_value, input_dummy, input_statement, 그 외 다양한 field의 분류명을 지정해 줍니다.</p><p>블록 전체 정의에서 쓰는 type과 같은 의미로 쓰이는 key는 바로 <strong>name</strong>입니다. 이 name에 할당된 이름은 input의 고유한 이름이 되며, 후에 code generation 시 값을 읽어 올 input을 지정하는 과정에서 요긴하게 쓰입니다.</p><p><strong>Check</strong>는 해당 input의 자료형을 강제해 주는 부분입니다. 이 예에서처럼 Number로 지정하면 해당 input의 자리에는 Number 형태만 받을 수 있게 되고, String으로 지정하게 되면 String 형태만 받을 수 있게 됩니다. 이렇게 형태를 정해 주지 않고 모든 형태를 다 받을 수 있게 하려면 check를 아예 생략해 버리면 됩니다.</p><p>두 번째 input은 dropdown입니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"field_dropdown"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"select"</span>,</span><br><span class="line">  <span class="attr">"options"</span>: [</span><br><span class="line">                [</span><br><span class="line">                   <span class="string">"+"</span>,</span><br><span class="line">                   <span class="string">"+"</span></span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                   <span class="string">"*"</span>,</span><br><span class="line">                   <span class="string">"*"</span></span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                   <span class="string">"-"</span>,</span><br><span class="line">                   <span class="string">"-"</span></span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"/"</span>,</span><br><span class="line">                    <span class="string">"/"</span></span><br><span class="line">                ]</span><br><span class="line">               ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type과 name의 경우 위에서 살펴본 첫 번째 value input과 동일한 의미로 쓰이고 있습니다.</p><p>주목해야 할 것은 <strong>options</strong> 부분입니다. 이 부분에서는 dropdown field를 클릭하면 나타나는 선택지를 정의하고 있지요. 사용자가 보는 이름과 프로그램 내에서 사용하는 이름을 한 쌍으로 묶은 뒤 이 이름 쌍들의 집합으로 option을 정의한다는 것은 Javascript 스타일로 정의할 때와 똑같습니다. 다만, new Blockly.FieldDropdown()이라는 생성자를 사용해 option을 초기화했던 Javascript 스타일과는 달리, JSON array 스타일에서는 간단하게 options라는 key에 option 리스트를 할당하는 것만으로 정의가 완료됩니다.</p><p>세 번째와 네 번째 input은 각각 빈 자리를 표현하는 dummy input과 두 번째 피연산자로 사용되는 value input을 정의하고 있습니다. 첫 번째나 두 번째 input을 정의하는 방식과 크게 다르지 않으므로 자세한 분석은 생략합니다. </p><h3 id="블록-전체의-속성-정의"><a href="#블록-전체의-속성-정의" class="headerlink" title="블록 전체의 속성 정의"></a>블록 전체의 속성 정의</h3><p>이제 남은 부분에서는 블록 전체의 디자인이나 속성에 관련된 정의를 담당하고 있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"inputsInline": true,</span><br><span class="line"> "nextStatement":null,</span><br><span class="line"> "previousStatement":null,</span><br><span class="line"> "colour": 260,</span><br><span class="line"> "tooltip": "Short version of arithmetic calculations",</span><br><span class="line"> "helpUrl": ""</span><br></pre></td></tr></table></figure><ul><li><p>inputsInline : Javascript 스타일에서 setInputsInline() 함수와 같은 역할을 합니다. True로 설정 시 input이 inline 정렬되며, automatic 정렬을 원한다면 이 부분을 생략하면 됩니다.</p></li><li><p>nextStatement &amp; previousStatement : Javascript 스타일에서 setPreviousStatement() &amp; setNextStatement() 함수와 같은 역할을 합니다. null로 설정 시 해당 방향으로 어떤 타입의 블록이 붙어도 상관 없다는 뜻이 되며, Number 나 String 등을 지정해 주면 그 부분에는 지정해 준 타입을 가지는 블록만 붙을 수 있습니다. 또한 아예 connection을 만들고 싶지 않을 때는 이 부분을 생략할 수 있습니다.</p></li><li><p>colour : Javascript 스타일에서 setColour()함수와 같은 역할입니다. 역시 HSV 중에서 Hue만 지정 가능하며, 0~360사이의 숫자로 원하는 색상을 지정할 수 있습니다.</p></li><li><p>tooltip &amp; helpUrl : Javascript 스타일에서 setToolTip() &amp; setHelpUrl() 함수와 같은 역할입니다. 각각 블록에 대한 tooltip과 help url을 설정하는 부분입니다.</p></li></ul><p>이렇듯, 블록의 기본 구조는 같기 때문에 JSON array 정의 스타일과 Javascript 정의 스타일은 많이 다른 듯 하면서도 비슷합니다. 또한 이 두 방법은 쓰임새나 장단점이 미묘하게 다르기 때문에, 두 방법을 모두 잘 알고 필요에 따라 알맞은 스타일을 사용하는 것이 필요합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;JSON-array-스타일로-블록-정의하기&quot;&gt;&lt;a href=&quot;#JSON-array-스타일로-블록-정의하기&quot; class=&quot;headerlink&quot; title=&quot;JSO
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
  <entry>
    <title>Blockly 사용법 4. JavaScript 스타일로 블록 정의하기</title>
    <link href="https://vleudive.github.io/2018/01/24/4_javascript_define_block/"/>
    <id>https://vleudive.github.io/2018/01/24/4_javascript_define_block/</id>
    <published>2018-01-24T01:05:48.000Z</published>
    <updated>2018-02-07T13:47:43.373Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_4.png" alt=""></p><h1 id="Javascript로-블록-정의하기"><a href="#Javascript로-블록-정의하기" class="headerlink" title="Javascript로 블록 정의하기"></a>Javascript로 블록 정의하기</h1><p>앞서 Blockly의 custom block을 정의하는 방법에는 Javascript만 이용하는 것과 JSON array를 같이 이용하는 것, 두 가지가 있다고 했습니다.<br>이번 포스트에서는 그 중 첫 번째 방법인 Javascript만 이용하는 방법으로 블록을 정의해 보겠습니다.</p><h2 id="정의할-블록"><a href="#정의할-블록" class="headerlink" title="정의할 블록"></a>정의할 블록</h2><p>이번과 다음 포스트에서 정의할 블록의 이름은 Short_math이며, 다음과 같은 모양을 하고 있습니다.</p><p><img src="/img/short_math_ex.png" alt="short_math"></p><p>이 블록은 Top+Bottom connection을 가지고 있으며, 2개의 Value Input을 가집니다. 또한 중간에 dropdown field가 있어 연산의 종류를 선택할 수 있습니다.<br>이 블록은 ‘짧은 표현식’을 구현하고 있습니다. C++ 이나 Java, Python 등의 문법으로 보자면 <strong>a+=b</strong> 식의 연산을 나타내는 블록입니다. 단, 중간에 dropdown field를 두어 연산의 종류를 선택할 수 있게 했기 때문에 결과적으로는 한 블록에서 a+=b, a-=b, a/=b, a*=b 의 연산이 모두 가능합니다.</p><h2 id="블록-정의-코드"><a href="#블록-정의-코드" class="headerlink" title="블록 정의 코드"></a>블록 정의 코드</h2><p>Javascript만 사용하여 Short_math를 정의하는 코드는 다음과 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Blockly.Blocks[<span class="string">'short_math'</span>] = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.appendValueInput(<span class="string">"a"</span>)</span><br><span class="line">        .setCheck(<span class="string">"Number"</span>);</span><br><span class="line">    <span class="keyword">this</span>.appendDummyInput()</span><br><span class="line">        .appendField(<span class="keyword">new</span> Blockly.FieldDropdown([[<span class="string">"+"</span>,<span class="string">"+"</span>], [<span class="string">"*"</span>,<span class="string">"*"</span>], [<span class="string">"-"</span>,<span class="string">"-"</span>], [<span class="string">"/"</span>,<span class="string">"/"</span>]]), <span class="string">"select"</span>)</span><br><span class="line">        .appendField(<span class="string">"="</span>);</span><br><span class="line">    <span class="keyword">this</span>.appendValueInput(<span class="string">"b"</span>)</span><br><span class="line">        .setCheck(<span class="string">"Number"</span>);</span><br><span class="line">    <span class="keyword">this</span>.setInputsInline(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.setPreviousStatement(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.setNextStatement(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.setColour(<span class="number">260</span>);</span><br><span class="line"> <span class="keyword">this</span>.setTooltip(<span class="string">"Short version of arithmetic calculations"</span>);</span><br><span class="line"> <span class="keyword">this</span>.setHelpUrl(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">코드를 하나하나 분석해 보겠습니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Block 정의 함수</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Block 정의 함수는 다음과 같은 형태를 하고 있습니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">Blockly.Blocks[<span class="string">'블록 이름'</span>]=&#123;</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 블록의 특성 정의</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 구문은 한 .js 파일 내에 여러 번 호출될 수 있으며, 해당 파일 안에 정의하고 싶은 블록의 개수만큼 호출되어야 합니다. JSON array를 활용하는 방식에서는 한 번의 함수 호출로 한꺼번에 여러 개의 블록을 정의할 수 있지만, Javascript 방식의 Blockly.Blocks[]의 경우 한 번에 한 블록밖에 정의하지 못합니다. </p><p>지금 정의하는 Short_math와 같은 간단한 블록을 정의할 때는 이 구문을 살짝 응용해서, init 메소드를 삭제하고 다음과 같이 사용해도 큰 문제는 없지만, mutator나 extension 고급 기능을 추가하게 되면 init 외에도 다양한 메소드를 추가하게 되기 때문에, 복잡한 구조의 블록의 경우 init을 생략하지 않는 위의 방법이 더 바람직합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Blockly.Blocks[<span class="string">'블록 이름'</span>]=&#123;</span><br><span class="line">        <span class="comment">// 블록의 특성 정의</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="첫-번째-Value-Input-정의"><a href="#첫-번째-Value-Input-정의" class="headerlink" title="첫 번째 Value Input 정의"></a>첫 번째 Value Input 정의</h3><p>Short_math 블록은 두 개의 value input을 가집니다. 그 중 첫 번째 Value Input을 추가하는 부분은 다음과 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.appendValueInput(<span class="string">"a"</span>)</span><br><span class="line">      .setCheck(<span class="string">"Number"</span>);</span><br></pre></td></tr></table></figure><p><strong>this</strong>는 지금 정의하고 있는 바로 이 블록, Short_math를 의미합니다.</p><p><strong>this.appendValueInput(“a”)</strong> 는 이 블록에 ‘a’라는 이름을 가지고 있는 value input을 추가하겠다는 뜻입니다. 여기서 정의해 준 이름 ‘a’는 블록에는 표시되지 않지만, code generation시에 block의 구성 요소를 지정하는 데 사용됩니다.</p><p><strong>setCheck(“Number”)</strong> 는 이 input이 받을 수 있는 자료형을 ‘Number’로 고정합니다. 이렇게 설정해 놓으면, ‘Number’ 이외의 자료형(ex: String) 을 가진 value input은 이 블록에 적용되지 못합니다. 이 함수의 이름이 setCheck인 것은, input 내에서 타입을 지정해 주는 프로퍼티의 이름이 ‘check’이기 때문입니다. Javascript 스타일로 블록을 정의할 때는 이런 식으로, setXXX(); 와 같은 하위 메소드를 호출해 블록 또는 input의 세부 프로퍼티를 조작합니다.</p><h3 id="Dropdown-Field-추가"><a href="#Dropdown-Field-추가" class="headerlink" title="Dropdown Field 추가"></a>Dropdown Field 추가</h3><p>두 번째로 정의해야 하는 부분은 dropdown field입니다. dropdown field는 다음과 같이 정의합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.appendDummyInput()</span><br><span class="line">       .appendField(<span class="keyword">new</span> Blockly.FieldDropdown([[<span class="string">"+"</span>,<span class="string">"+"</span>], [<span class="string">"*"</span>,<span class="string">"*"</span>], [<span class="string">"-"</span>,<span class="string">"-"</span>], [<span class="string">"/"</span>,<span class="string">"/"</span>]]), <span class="string">"select"</span>)</span><br><span class="line">       .appendField(<span class="string">"="</span>);</span><br></pre></td></tr></table></figure><p>이 부분에서 <strong>“Field 사용 시에는 Dummy input을 같이 사용하는 경우가 많다”</strong> 는 특징이 잘 드러납니다. 여기서도 this는 지금 정의하고 있는 Short_math 블록을 나타냅니다.</p><p><strong>appendDummyInput()</strong> 은 이 블록에 dummy input을 추가하는 함수입니다. 이 dummy input의 field로 dropdown field를 추가하게 될 것입니다.<br>이 코드에서 총 두 번 등장하는 <strong>apendField()</strong> 구문이 바로 input에 field를 추가하는 구문입니다. 위에서 등장한 setXXX() 류의 함수가 블록에 이미 있던 기본 property를 조작하는 것에 가깝다면, appendField() 함수는 해당 블록에 아예 새로운 field를 추가해 블록의 구조 자체를 바꾸는 함수입니다.</p><p>첫 번째로 등장하는 appendField()에는 <strong>new Blockly.FieldDropdown([[“+”,”+”],[“<em>“,”</em>“],[“-“,”-“],[“/“,”/“]]),”select”)</strong> 라는 구문이 파라미터로 전달되는데, 이 파라미터는 바로 새로운 dropdown field를 생성하는 생성자 구문입니다. </p><p>그 중 <strong>[[“+”,”+”],[“<em>“,”</em>“],[“-“,”-“],[“/“,”/“]]</strong> 부분은 dropdown field 의 option을 지정하는 리스트입니다. 리스트 내 항목의 개수는 얼마든지 늘릴 수 있으며, 이 리스트는 한 쌍의 string이 들어 있는 더 작은 리스트의 집합으로 이루어져 있습니다. 이 string 쌍에서, 앞의 string은 블록 사용자가 직접 보고 선택하게 될, 즉 블록에 직접 표시될 option 이름이고 뒤의 string은 프로그램 내에서 사용되는 option이름입니다. 이처럼 두 이름을 같게 해도 무방합니다. 또한 <strong>“select”</strong> 는 이 dropdown field 자체의 이름을 지정한 것입니다. 후에 code generation 등을 할 때 지정자로서 요긴히 쓰입니다.</p><p>두 번쨰로 등장하는 appendField()에는 “=”이라는 string 하나만 전달되었습니다. 이는 =라는 문자를 표시하는 label로써, label은 이런 식으로 string 하나만 전달해서 추가할 수도 있습니다.</p><h3 id="두-번째-Value-Input-정의-및-블록-세부-속성-정의"><a href="#두-번째-Value-Input-정의-및-블록-세부-속성-정의" class="headerlink" title="두 번째 Value Input 정의 및 블록 세부 속성 정의"></a>두 번째 Value Input 정의 및 블록 세부 속성 정의</h3><p>두 번째 Value Input을 정의하고 남아 있는 블록의 세부 속성을 정의하는 코드는 다음과 같습니다. 두 번째 value input을 정의하는 구문은 첫 번째 value input을 정의하는 구문과 거의 유사하므로 넘어갑니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.appendValueInput(<span class="string">"b"</span>)</span><br><span class="line">    .setCheck(<span class="string">"Number"</span>);</span><br><span class="line"><span class="keyword">this</span>.setInputsInline(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">this</span>.setPreviousStatement(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">this</span>.setNextStatement(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">this</span>.setColour(<span class="number">260</span>);</span><br><span class="line"><span class="keyword">this</span>.setTooltip(<span class="string">"Short version of arithmetic calculations"</span>);</span><br><span class="line"><span class="keyword">this</span>.setHelpUrl(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>코드의 세 번째 줄부터는 블록 자체에 대한 세부 속성을 정의합니다.</p><p><strong>setInputsInline()</strong> 은 Input을 Inline 형태로 정렬할 것인지 아닌지를 결정하는 함수입니다. 파리미터로는 true, false의 boolean 값이 들어가고, true로 설정되었을 경우 inline 정렬로 설정됩니다.<br>Inline정렬과, inline 정렬이 아닌 블록(automatic 정렬이라고도 합니다.)은 다음과 같이 input 결합부의 모양에서 차이가 납니다.</p><p><img src="/img/inline_ex.png" alt="inline_ex"></p><p><img src="/img/automatic_ex.png" alt="auto_ex"></p><p>Automatic 정렬의 경우 input이 많아지면 블록이 위아래로 길어지는 형태가 되기 때문에, output이 있는 블록보다는 위 또는 아래 connection이 있는 블록에 적용하는 것이 나중에 다른 블록과 결합했을 때 더 보기 좋아집니다.</p><p><strong>setPreviousStatement()</strong> 는 previous statement(top connection)의 유무를 정해 주는 함수입니다. 생략 시 previous statement가 없는 블록이 되고, 파라미터를 true로 하여 이 함수를 호출해 주면 블록에 previous statement가 생겨 다음과 같은 형태가 됩니다.</p><p><img src="/img/top_block.png" alt="prev_ex"></p><p><strong>setNextStatement()</strong> 는 next statement(bottom connection)의 유무를 정해 주는 함수입니다. setPreviousStatement()처럼 생략할 시 next statement가 없는 블록이 됩니다. 파라미터를 true로 한 채 이 함수를 호출하면 블록은 다음과 같은 모양이 되지요.</p><p><img src="/img/bottom.png" alt="next_ex"></p><p>이번 예에서는 setPreviousStatement()와 setNextStatement()를 둘 다 호출했으므로, previous statement와 next statement가 모두 존재하는 블록이 만들어집니다. 이런 형태가 되지요.</p><p><img src="/img/top_bottom_block.png" alt="both_ex"></p><p><strong>setColour</strong> 는 블록의 색깔을 설정해 주는 함수입니다. Blockly는 블록의 색을 정의할 때 HSV(Hue-Saturation-Value) 모델들 이용합니다. 그 중에서도 이 함수로 직접 정해 줄 수 있는 값은 Hue이죠. 이렇게 하면 색상의 다양성을 보장하면서도, 특정 블록이 너무 튀어 보이지 않고 모든 블록의 색이 잘 어우러지도록 할 수 있습니다. 만약 Hue 외에 Saturation과 Value도 바꾸어 전체적인 색감을 조정하고 싶다면, 다른 설정 파일에 정의되어 있는 해당 값을 직접 바꾸어 줄 수도 있습니다. 가장 쉽게 바꿀 수 있는 Hue는 각도로 표현되며, 0~360도 사이의 값으로 지정해 주어야 합니다.<br>각도 값에 따른 색상의 변화는 아래 스펙트럼에서 확인해 볼 수 있습니다.</p><p><img src="/img/hue_spectrum.png" alt="spectrum"></p><p><strong>setTooltip</strong> 함수는 블록에 tooltip을 부여해 줍니다. Tooltip은 블록에 마우스 커서를 올려 놓고 일정 시간이 지나면 나타나는 작은 글 상자이며, 이 안에 들어가는 문구를 사용자가 마음대로 정해 줄 수 있습니다. 보통 블록에 대한 간략한 설명을 담아 놓으며, 이 함수의 파라메터로 들어가는 String 값이 해당 블록의 tooltip 내용이 됩니다.</p><p>마지막으로, <strong>setHelpUrl()</strong> 함수가 있습니다. 이 함수의 파라미터로는 string이 들어가며, 이 string은 특정 URL을 나타냅니다. Tooltip만으로는 블록에 대해 충분히 설명할 수 없을 때, 더 상세한 설명을 제공해 주는 페이지로 직접 이동할 수 있게 하기 위해 이 함수를 이용합니다. Help Url이 설정된 블록 위에서 오른쪽 마우스를 클릭하면 다음과 같은 context menu가 나타나고, Help를 클릭 시 이 함수를 통해 지정해 놓은 웹 페이지로 바로 이동합니다.</p><p><img src="/img/help_context.png" alt="help_context_menu"></p><p>이렇게 해서 하나의 완전한 블록이 정의됩니다. 아직 실제 코드가 매핑되어 있지는 않지만, 블록의 모양만큼은 완성되어 있지요.<br>이런 블록을 정의하는 방법에는 한 가지가 더 있는데, 그 방법에 대해서는 다른 포스트에서 다루겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Javascript로-블록-정의하기&quot;&gt;&lt;a href=&quot;#Javascript로-블록-정의하기&quot; class=&quot;headerlink&quot; title=&quot;Javascript로
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
  <entry>
    <title>Blockly 사용법 3. Input과 Field 이해하기</title>
    <link href="https://vleudive.github.io/2018/01/23/3_input_types/"/>
    <id>https://vleudive.github.io/2018/01/23/3_input_types/</id>
    <published>2018-01-23T08:10:02.000Z</published>
    <updated>2018-02-07T13:43:10.834Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_3.png" alt=""></p><h1 id="Blockly-Input-Types"><a href="#Blockly-Input-Types" class="headerlink" title="Blockly Input Types"></a>Blockly Input Types</h1><p>Blockly 커스텀 블록의 형태에는 여러 가지가 있습니다. 보통 Input 과 Output이 어떤 것이냐, Connection의 형태는 어떻냐에 따라 블록의 모양이 달라집니다.</p><p>제일 먼저 Blockly 블록의 input과 output, 그리고 connection이 무엇인지 정의해 보면 이렇습니다.</p><ul><li>Input: 블록의 ‘빈 칸’입니다. 여기에 다양한 값 또는 명령과 매핑되는 블록들이 붙어,전체 구문을 완성시킵니다. Input 은 블록의 특성에 따라 여러 개일 수도, 한 개만 있을 수도 있습니다.<br>또한 input은 크게 <strong>Dummy Input, Value Input, Statement Input</strong>의 세 가지 타입으로 나누어집니다. 이 세 가지 타입과 별개로, input을 가지는 블록은 블록 정의 시에 정하게 되는 ‘check’라는 요소를 가지며, 이 ‘check’에는 어떤 자료형(ex: String, Number…)의 input이 와야 할지를 정해 줄 수 있습니다.</li></ul><ul><li>Output: 블록의 왼쪽으로 나와 있는 ‘돌출부’ 입니다.<br>한 블록의 output은 다른 블록의 value input으로 들어갈 수 있습니다. Output은 connection의 양상이나 블록의 특성에 따라 생략 가능하지만, input과는 다르게 여러 개를 지정할 수는 없습니다.<br>Input에 check라는 특정 타입을 설정할 수 있는 것처럼, output의 형태 또한 정의할 수 있습니다. 역시 블록 생성 시에 정의되며, String, Number 등을 정해 줄 수 있습니다.</li></ul><ul><li><p>Connection : 한 블록과 다른 블록의 ‘연결 상태’를 나타냅니다. Connection의 종류에는 다음과 같은 것이 있습니다.</p><ul><li><p>No connections: 문자 그대로 다른 어떤 블록과도 연결되지 않는 블록의 경우입니다. 블록의 모양은 다음과 같습니다.</p><p><img src="/img/no_connection_block.png" alt="no_connect"></p></li><li><p>Top+Bottom connections: 해당 블록의 위 아래에 다른 블록이 붙을 수 있는 형태입니다. 블록의 모양은 다음과 같습니다.</p><p><img src="/img/top_bottom_block.png" alt="top_bottom"></p></li><li><p>Top connection: 해당 블록의 위에만 다른 블록이 붙습니다. 블록의 모양은 다음과 같습니다.</p><p><img src="/img/top_block.png" alt="top"></p></li><li><p>Bottom connection: 해당 블록의 아래에만 다른 블록이 붙습니다. 블록의 모양은 다음과 같습니다.</p><p><img src="/img/bottom.png" alt="bottom"></p></li></ul></li></ul><h2 id="Input의-종류"><a href="#Input의-종류" class="headerlink" title="Input의 종류"></a>Input의 종류</h2><p>상술했듯이, Blockly 블록의 Input에는 <strong>Dummy Input, Value Input, Statement Input</strong>의 세 가지가 있습니다.<br>모두 성격이나 역할이 다르기 때문에 블록의 목적이나 특성에 따라 다른 타입의 Input이 사용되고, 한 블록에 여러 가지 종류의 Input이 함께 쓰이는 경우도 빈번합니다.</p><h3 id="Dummy-Input"><a href="#Dummy-Input" class="headerlink" title="Dummy Input"></a>Dummy Input</h3><p>이 타입의 input은 블록과 직접적으로 연결되는 것이 아니며 특정한 피연산자나 값을 나타내는 input도 아닙니다. 값을 직접 나타내는 것은 아니지만 블록의 이름을 나타내는 label을 담거나, 선택 가능한 목록을 나타내는 dropdown menu field를 추가하거나, external input을 받을 때 강제개행과 비슷한 용도로 쓰이는 등 다양한 용도로 쓰이지요.<br>한 마디로 말하면 보조적인 역할을 하는 요소라 할 수 있지만, 한편으로는 블록의 모양이나 성질을 구성하는 데 있어서 중요한 역할을 하는 input입니다.<br>실제로 모양을 가지고 보여지는 블록이 아니기 때문에 특별한 형태는 없습니다.</p><h3 id="Value-Input"><a href="#Value-Input" class="headerlink" title="Value Input"></a>Value Input</h3><p>Value input은 value input을 가진다고 정의된 블록과 결합할 수 있습니다. 실제 피연산자나 값을 나타내며, 주로 함수의 파라미터 등으로 들어갑니다.<br>또한 이 타입의 input은 output을 가지는 짧은 블록의 형태로 정의되는 경우가 많습니다. 보통 이런 모양입니다.</p><p><img src="/img/value_input_ex.png" alt="value_ex_1">      </p><p><img src="/img/value_input_ex_2.png" alt="value_ex_2"></p><p>Value Input의 사용 시 주의하실 점은, <strong>Block 정의 시 정해 준 자료형이 아닌 다른 자료형의 input은 해당 블록에 연결할 수 없다</strong>는 것입니다. 즉, input으로 String 형태만 받기로 정의된 블록에 Number를 output으로 가지는 value input이 결합할 수 없다는 것입니다.<br>하지만 실제로 editor에서 타입이 맞지 않는 input과 block을 연결하려고 하면 제대로 붙지 않고 한쪽 블록이 튕겨져 나가 버리므로, 실제 사용 시에는 타입이 맞는 연결인지 여부를 바로 알 수 있습니다.</p><h3 id="Statement-Input"><a href="#Statement-Input" class="headerlink" title="Statement Input"></a>Statement Input</h3><p>일부 블록의 경우, value 대신 statement를 input으로 받기도 합니다. 이때 statement는 ‘구문’에 가깝게 번역되며, 해당 블록의 범위 내에서 다시 실행되어야 하는 서브 동작을 나타냅니다. 통상적인 고급 언어에 대입해 보면, if문이나 for 문, while 문, 함수 정의 시 중괄호 안쪽이나 콤마(:) 아래쪽에 들여쓰기로 들어가게 되는 하부 동작과 같다고 할 수 있습니다.<br>블록의 형태를 중심으로 보았을 때, statement input을 나타내는 블록들은 주로 output이 아닌 conncetion을 가지며, Top+Bottom connection을 가지도록 정의되는 경우가 많습니다. 또한 statement input을 가지는 블록은 아래 왼쪽 그림과 같이 생겼으며, statement input과 결합할 경우 아래 오른쪽 그림과 같은 모양이 됩니다.</p><p><img src="/img/statement_require_ex.png" alt="statement_block_ex">               </p><p><img src="/img/statement_filled_ex.png" alt="statement_filled"> </p><p>이렇게 결합시켜 놓은 블록들은 전체가 한 그룹으로 움직입니다. (Value input이 필요한 블록에 해당 input을 결합시켰을 때에도 마찬가지입니다.) 그렇기 때문에 editor 상에서 statement input의 전체 모음을 감싸고 있는 외곽 블록을 움직이면 전체 그룹이 같이 움직이고, 끼워 넣은 statement input 중에 정의 또는 code generation 코드가 잘못된 것이 있다면 해당 그룹에 있는 다른 블록들에까지 영향을 미쳐 전체 그룹의 코드가 제대로 만들어지지 않기도 합니다.</p><h2 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h2><p>Blockly에는 field라는 개념도 존재합니다. 이 field들은 블록에 다양한 UI요소를 붙여, 블록을 좀 더 쉽고 가시적인 방법으로 다룰 수 있게 해 줍니다.<br>보통 field를 사용할 때는 <strong>dummy input과 함께 사용하는 편</strong>입니다. (Blockly Developer Tools에서 확인해 보면 dummy input에 field 블록이 물려 있는 형태를 하고 있습니다.) 이 특성은 JSON array로 블록을 정의할 때보다 Javascript 스타일로 정의할 때 더 확연히 드러나는 편인데, 자세한 점은 다른 포스트에서 서술합니다.<br>Blockly에서 사용하는 field에는 다음과 같은 것들이 있습니다.</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>말 그대로 라벨로 사용하는 field입니다. Label은 굉장히 자주 쓰이는 field입니다. 블록의 이름이나, 블록 자체에 표시되는 간단한 설명문 등은 모두 이 label을 사용하여 만들어집니다. 이처럼 활용성이 좋기 때문에, label field는<br>아예 자신만의 notation이 따로 있습니다. 코드를 보면 더 확실히 이해가 가실 것입니다. 블록 정의는 JSON array 스타일을 기준으로 하겠습니다.</p><p>이 예제에서 정의할 블록은 다음과 같이 생겼습니다. 간단한 라벨 두 개를 가지고 있는 블록이지요.</p><p><img src="/img/label_ex.png" alt="label_ex"></p><p>정의에 사용하는 Javascript 함수는 생략하고 블록의 속성을 정의하는 JSON array 부분만 살펴보겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>:<span class="string">"example_label"</span>,</span><br><span class="line">  <span class="string">"message0"</span>: <span class="string">"a label %1 and another label"</span>,</span><br><span class="line">  <span class="string">"args0"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>:<span class="string">"input_dummy"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적으로 label field는 이런 식으로 사용할 수 있습니다. ‘message0’ 부분에 placeholder인 %1을 넣어 이 자리에 dummy input이 들어간다는 것을 나타내고 있습니다. 여기서 dummy input은 블록 내에서의 줄 바꿈을 위해 사용되고 있습니다.<br>label의 이름과 내용은 따로 정의하지 않고, message0 부분에 한 줄로 정의했습니다.<br>다른 포스트에서 더 자세히 서술하겠지만, label과 label 사이에 input이 들어갈 경우는 이런 식으로 placeholder를 사용합니다.</p><p>또 다른 스타일의 label 사용 방법을 보겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"example_label"</span>,</span><br><span class="line">  <span class="string">"message0"</span>:<span class="string">"%1 %2 %3"</span>,</span><br><span class="line">  <span class="string">"args0"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>:<span class="string">"field_label"</span>,</span><br><span class="line">      <span class="string">"text"</span>:<span class="string">"a label"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>:<span class="string">"input_dummy"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"and another label"</span></span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기에서는 message0 부분이 전부 placeholder로 정의되어 있습니다. 이 자리를 각각 field_label, dummy input, “and another label”이라는 string이 순서대로 채우는 형태입니다.<br>먼저 “args0” 배열의 첫 번째 부분인 “field_label” 정의 부분을 보면, “input_dummy” 등을 사용하지 않고 곧바로 field 타입인 “field_label”을 사용한 것을 볼 수 있습니다. Label처럼 자주 쓰이는 field들은 상술했듯이 자신만의 notation이 있기 때문에 이런 식으로 정의하는 것도 가능합니다.<br>배열의 그 다음 부분에서는 dummy input을 넣어 줄바꿈을 표현하고 있습니다. 주목해야 할 것은 세 번째 부분입니다. 중괄호로 묶지도 않고, key도 부여하지 않은 채 그저 string 한 줄만 달랑 정의되어 있습니다.<br>사실 Label은 이런 식으로 정의하는 것도 가능합니다. 아무 형식 없는 plain string을 전달해 주면, 그 string은 label로 해석됩니다. 단, 이렇게 넣어 줄 수 있으려면 message0의 value를 정해 줄 때 해당 string이 들어갈 수 있는 placeholder를 넣어 주어야 합니다.</p><p>또한, 위의 코드에서 “a label” 라벨을 정의한 방식으로 명시적으로 label을 정의할 경우, “type”,”text” 외에도 “style”이라는 키를 추가하여 라벨에 CSS 기반 스타일을 부여할 수도 있습니다.</p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><img src="/img/image_ex.png" alt="image_ex"></p><p>이 field는 문자 그대로, 블록에 아이콘 등의 이미지를 삽입하기 위해 사용합니다. Image field가 삽입될 경우, image의 크기에 맞추기 위해 블록의 크기가 자동으로 변경됩니다.<br>Image의 경우도 label과 마찬가지로 자신만의 indicator를 따로 가지기 때문에, placeholder만 마련되어 있다면 바로 “field_image” 형태로 블록에 삽입할 수 있습니다.<br>이미지 URL은 상대 경로로 지정해 줄 수 있으며, 웹 상에 있는 이미지를 URL을 이용해 바로 접근해 삽입하는 것도 가능합니다. </p><p>Image field는 독특하게도  “alt”라는 독특한 요소를 가지고 있는데, 이것은 오류로 인해 이미지가 표시되지 않거나, 접근성을 고려해야 하는 상황에서 이미지 대신에 표시될 수 있는 설명문을 말합니다. 어떤 이유에서든 이미지를 표시할 수 없는 상황이 되면, 자동으로 “alt” 에 지정된 string이 대신 출력됩니다.</p><h3 id="Dropdown"><a href="#Dropdown" class="headerlink" title="Dropdown"></a>Dropdown</h3><p>여러 항목 중 하나를 선택할 때 사용되는 drop-down field입니다. Input의 값보다는, block이 나타내는 연산에 설정해 줄 옵션 등을 선택하는 데 주로 사용됩니다. Dropdown field를 정의하는 코드는 다음과 같습니다.<br>역시 함수는 제외하고 블록 설정을 나타내는 JSON array만 표시하겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"example_dropdown"</span>,</span><br><span class="line">  <span class="string">"message0"</span>: <span class="string">"drop down: %1"</span>,</span><br><span class="line">  <span class="string">"args0"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"field_dropdown"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"FIELDNAME"</span>,</span><br><span class="line">      <span class="string">"options"</span>: [</span><br><span class="line">        [ <span class="string">"first"</span>, <span class="string">"ITEM1"</span> ],</span><br><span class="line">        [ <span class="string">"second"</span>, <span class="string">"ITEM2"</span> ]</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"colour"</span>:<span class="number">290</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드가 정의하는 블록의 모습은 대략 이렇습니다.</p><p><img src="/img/dropdown_ex.png" alt="drowdown_ex"></p><p>Dropdown 옵션으로 ‘first’,’second’를 가지고 있는 것을 볼 수 있습니다. 이런 dropdown option은 JSON array 내에서는 리스트의 형태로 나타납니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">"first"</span>, <span class="string">"ITEM1"</span> ],</span><br><span class="line">[ <span class="string">"second"</span>, <span class="string">"ITEM2"</span> ]</span><br></pre></td></tr></table></figure><p>이런 식입니다. 리스트의 앞 부분에 있는 원소 “first”와 “second”는 블록 사용자가 실제로 보게 될, 즉 dropdown field 내에 실제로 표기되는 이름이고 두 번째로 오는 “ITEM1”과 “ITEM2” 는 코드 상에서 사용하는 이름입니다.<br><strong>사용자는 앞에 오는 이름(실제 표기되는 이름)을 보고 선택을 하지만, 코드 상에서 조건 등을 설정할 때는 코드 상의 이름(두 번째 이름)으로 각 option을 식별합니다.</strong><br>이처럼 사용자가 실제 선택하는 이름과 코드 상에서 사용되는 indicator가 다르므로, 헷갈리지 않도록 주의해야 합니다. 또는 아예 양쪽 이름을 똑같이 설정해 주는 것도 방법입니다.</p><h3 id="그-외의-field"><a href="#그-외의-field" class="headerlink" title="그 외의 field"></a>그 외의 field</h3><ul><li>Checkbox</li></ul><p><img src="/img/checkbox_ex.png" alt="check_ex"></p><p>클릭으로 toggle할 수 있는 checkbox를 블록 내에 삽입할 때 사용하는 field입니다. 이 field에서는 true와 false로 표현되는 boolean 값을 얻을 수 있습니다.</p><ul><li>Colour picker</li></ul><p><img src="/img/colourpicker_default_ex.png" alt="colour_ex"></p><p> 색상 선택 패널을 표시해 주는 field입니다. 웹 환경에서라면 Javascript 코드를 약간 조작해 아래 사진과 같이 기본으로 표시되는 색상 패턴 외에 다른 색상 배치를 가지는 패널을 표시하게 할 수도 있습니다.</p><p> <img src="/img/colourpicker_custom_ex.png" alt="colour_ex_2"></p><ul><li>Variable</li></ul><p><img src="/img/variable_field_ex.png" alt="variable_ex"></p><p>Blockly 역시 코딩에 사용되기 때문에 변수를 쓸 일이 생깁니다. Variable field는 이런 variable을 input으로 받는 블록에 사용됩니다. 이런 블록에 variable input을 결합하는 기본 방법은 미리 만들어진 variable block을 하나하나 끌어와 원래 블록에 붙이는 것인데, 꽤 번거로운 과정이므로 variable field를 이용해 input 입력 과정을 단순화할 수 있습니다.<br>Variable field는 dropdown field와 꽤 흡사하게 생겼지만 기능은 다릅니다. 먼저 이 field에는 정의 시에 기본으로 넣어 준 variable의 이름이 우선적으로 표시되며, 새 variable을 만들 수 있는 기능과 variable의 이름을 바꿀 수 있는 기능을 지원합니다.</p><ul><li>Angle</li></ul><p><img src="/img/angle_ex.png" alt="angle_ex"></p><p>각도를 지정할 때 사용되는 field입니다.  Field를 클릭 시 360도까지 지정 가능한 각도기 모양이 출력되며, 이 각도기 모양 위에서 마우스 커서를 이동하여 숫자 입력 없이 직관적으로 각도를 입력할 수 있습니다.</p><ul><li>Date</li></ul><p><img src="/img/date_ex.png" alt="date_ex"></p><p>날짜를 지정할 때 사용되는 field입니다. Field를 클릭 시 달력 UI가 출력되며, 이 달력에서 날짜를 선택할 수 있습니다. 하지만 이 field는 Blockly의 기본 컴파일 목록에는 들어 있지 않습니다. (자주 쓰지도 않고, 기능이 복잡한 편이기 때문입니다.) 그렇기 때문에 date field를 사용하려면 프로젝트 상단에 <strong>goog.require(‘Blockly.FieldDate’)</strong> 를 추가해 주어야 합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Blockly-Input-Types&quot;&gt;&lt;a href=&quot;#Blockly-Input-Types&quot; class=&quot;headerlink&quot; title=&quot;Blockly Inp
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
  <entry>
    <title>Blockly 사용법 2. Custom Block 정의 시작하기</title>
    <link href="https://vleudive.github.io/2018/01/23/2_define_blocks/"/>
    <id>https://vleudive.github.io/2018/01/23/2_define_blocks/</id>
    <published>2018-01-23T03:50:19.000Z</published>
    <updated>2018-02-07T14:20:28.438Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_2.png" alt=""></p><h1 id="Blockly-Custom-Block-정의-개요"><a href="#Blockly-Custom-Block-정의-개요" class="headerlink" title="Blockly Custom Block 정의(개요)"></a>Blockly Custom Block 정의(개요)</h1><p>Blockly의 장점은 기본 블록 외에도 어플리케이션이 필요로 하는 다양한 custom block을 마음껏<br>만들어 사용할 수 있다는 것입니다. Custom block을 만들려면 크게 다음과 같은 두 가지 단계를 거칩니다.</p><ol><li>Block의 모양, 색깔,  다른 블록과의 결합 정보 등을 정의한다.</li><li>만들어진 Block에 고급 언어로 된 코드를 매핑한다.</li></ol><p>여기서는 첫 번째 단계인 Block definition의 방법을 대략적으로 설명하겠습니다.</p><h2 id="Javascript-vs-JSON"><a href="#Javascript-vs-JSON" class="headerlink" title="Javascript vs. JSON"></a>Javascript vs. JSON</h2><p>Blockly block은 크게 두 가지 방법으로 정의 가능합니다. 두 방법 모두 Javascript를<br>기반으로 하지만, 한 가지 방법은 처음부터 끝까지<strong>Javascript</strong> 스타일로<br>블록 속성을 정의하는 한편, 다른 방법은 <strong>JSON Array</strong> 형식으로 블록 속성을 정의합니다.<br>간단한 예를 들어 보겠습니다.</p><p><img src="/img/string_length_block.png" alt="string_length"></p><p>이 블록은 String을 받았을 때 그 길이를 리턴해 주는 기능을 합니다.<br>Javascript 스타일과 JSON Array 스타일로 각각 이 블록을 정의해 보면 다음과 같습니다.</p><ul><li>Javascript 스타일</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Blockly.Blocks[<span class="string">'string_length'</span>]=&#123;</span><br><span class="line">    <span class="keyword">this</span>.appendValueInput(<span class="string">'Value'</span>)</span><br><span class="line">         .appendField(<span class="string">'length of'</span>)</span><br><span class="line">         .setCheck(<span class="string">'String'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setOutput(<span class="literal">true</span>,<span class="string">"Number"</span>);</span><br><span class="line">    <span class="keyword">this</span>.setColour(<span class="number">160</span>);</span><br><span class="line">    <span class="keyword">this</span>.setTooltip(<span class="string">'tooltip for this block'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setHelpUrl(<span class="string">'http://.....'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (자세한 코드 해석은 다른 포스트에서 다루겠습니다.)</p><ul><li>JSON Array 스타일</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Blockly.defineBlocksWithJsonArray(</span><br><span class="line">   [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>:<span class="string">"string_length"</span>,</span><br><span class="line">         <span class="string">"message0"</span>:<span class="string">"length of %1"</span>,</span><br><span class="line">         <span class="string">"args0"</span>:[</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="string">"type"</span>:<span class="string">"input_value"</span>,</span><br><span class="line">                       <span class="string">"name"</span>:<span class="string">"Value"</span>,</span><br><span class="line">                        <span class="string">"check"</span>:<span class="string">"String"</span></span><br><span class="line">                   &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="string">"output"</span>:<span class="literal">null</span>,</span><br><span class="line">         <span class="string">"colour"</span>:<span class="number">160</span>,</span><br><span class="line">         <span class="string">"tooltip"</span>:<span class="string">"tooltip for this block"</span>,</span><br><span class="line">         <span class="string">"helpUrl"</span>:<span class="string">"http://....."</span></span><br><span class="line">      &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>(역시 자세한 코드 해석은 다른 포스트에서 다루겠습니다.)</p><p>하나 주의하실 점은,<br>JSON array 형태로 블록 정의를 할 때, <strong>파일 형태를 .json으로 하면 안 된다</strong>는 것입니다.<br>JSON array 형태로 정의할 때도 정의가 들어 있는 파일의 확장자는 <strong>.js</strong> 이며, Javascript 파일 내에서<br><strong>Blockly.defineBlocksWithJsonArray()</strong> 함수의 파라미터로 블록의 정의가 담긴 JSON array를 넘겨 주는 형태입니다.</p><p>후술할 Blockly Developer Tools 에서는 이 함수 없이 JSON array만 달랑 생성해 주기 때문에 처음에는 헷갈릴 확률이 매우 높습니다.</p><p>정리하자면, Block 정의는 JSON 원본 파일 안에 담는 것이 아니고, Javascript 파일 안에, Javascript로 구현된 Blockly 라이브러리의 함수에 파라미터로 전달되는 것입니다.</p><h2 id="어떤-형태로-정의하는-것이-나은가"><a href="#어떤-형태로-정의하는-것이-나은가" class="headerlink" title="어떤 형태로 정의하는 것이 나은가?"></a>어떤 형태로 정의하는 것이 나은가?</h2><p>결론부터 말하면, Google 공식 문서에서는 <strong>JSON array 형태의 정의를 권장</strong>합니다.<br>일단 Cross-platform 형식인데다가, 다양한 언어권에서 블록을 정의할 때 표준으로 사용하기 훨씬 적합하기 때문이지요.</p><p>다만, 예외는 있습니다.</p><p>다른 포스트에 따로 서술할 Mutator, Extension과 같은 고급 기능을 사용해야 할 때는, JSON array가 아니라<br>Javascript로 구현하는 것이 낫습니다. 사실 Mutator의 경우 간단한 형태일 때는 JSON array와 Javascript 형식을 적절히 섞은 형태로<br>정의하는 쪽으로 기울고 있긴 하지만, 많이 복잡한 형태가 될 경우에는 아직도 Javascript만으로 정의하는 것이 더 편합니다. JSON은 아주 복잡한 추가 기능을<br>표현하지 못하기 때문입니다.</p><p>이렇게 각 방법에 장단점이 있으므로, 양쪽 방법 모두를 숙지하고 필요할 때마다 적절히 섞어 쓰는 것이 필요합니다.<br>실제로 기본으로 제공되는 Blockly 라이브러리 소스코드를 보아도, 각 블록의 특성에 따라 다른 방식을 사용하여 정의한<br>것을 볼 수 있습니다.</p><h2 id="Blockly-Developer-Tools"><a href="#Blockly-Developer-Tools" class="headerlink" title="Blockly Developer Tools"></a>Blockly Developer Tools</h2><p>원래 블록 정의는 코딩만으로 충분히 가능하기는 하지만, 코딩만으로는 지금 만들고 있는 블록이 어떤 모양이 될지,<br>결합부는 제대로 만들어졌는지, 색깔은 어떤지 가늠하기 어렵습니다. 그래서 만들어진 것이 <a href="&quot;https://blockly-demo.appspot.com/static/demos/blockfactory/index.html&quot;">Blockly Developer tools</a> 입니다.</p><p><img src="/img/developer_tools.png" alt="dev_tools"></p><p>이 페이지에서는 이미 정의된 component를 이용하여 시각적인 방법으로 블록 정의를 할 수 있습니다.<br>만들어지는 블록의 모습을 Preview 창에서 실시간으로 확인할 수 있고, Block Definition이나 Generator Stub 창에서는 Block definition과<br>Code generation을 위한 코드도 생성해 주기 때문에 구문이 헷갈리거나 복잡한 코딩을 하기 싫을 때 아주 유용하게 사용할 수 있습니다.</p><p>또한 이 툴에서는 Block Exporter 와 Workspace Factory 같은 기능도 제공하기 때문에, Block을 자신이 만든 editor에 추가하고 웹 페이지에<br>올리는 작업도 훨씬 쉽게 할 수 있습니다.</p><p>단, 이 좋은 도구에도 단점은 있습니다. 바로 <strong>완전한 코드를 생성해 주지 않는다</strong>는 것입니다.<br>상술했듯이, Block Definition과 Generator Stub창에서 생성된 코드를 볼 수 있고 Block Exporter 기능을 통해 코드 다운로드도 가능하지만,<br>이 코드를 그대로 사용하면 오류가 발생합니다. 완성된 코드가 아니기 때문이지요.</p><p>Block Definition에서 생성해 주는 코드는 Javascript 포맷의 경우 제대로 완성되어 있지만, JSON Array 포맷의 경우<br>문자 그대로 ‘달랑 JSON array만’ 생성해 줍니다. 위에서 설명한 Blockly.defineBlocksWithJsonArray() 같은 함수를 추가하고<br>이를 .js 파일에 저장하는 것은 개발자가 할 일이지요.</p><p>Generator stub의 경우, 정작 중요한 code를 완성시켜 주지 않습니다. 원하는 언어로 코드를 매핑하려면 이 부분에서<br>만들어 준 코드를 참고하여 직접 코드 조각을 만들어 매핑시켜야 합니다.</p><p>이런 점들만 주의하신다면 Blockly Developer Tools는 Blockly 라이브러리를 사용할 때 매우 훌륭한 도구가 되어 줄 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Blockly-Custom-Block-정의-개요&quot;&gt;&lt;a href=&quot;#Blockly-Custom-Block-정의-개요&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
  <entry>
    <title>Blockly 사용법 1. Blockly 개요</title>
    <link href="https://vleudive.github.io/2018/01/23/1_Blockly_intro/"/>
    <id>https://vleudive.github.io/2018/01/23/1_Blockly_intro/</id>
    <published>2018-01-23T02:40:39.000Z</published>
    <updated>2018-02-07T13:35:19.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Cover_1.png" alt=""></p><h1 id="Blockly란"><a href="#Blockly란" class="headerlink" title="Blockly란?"></a>Blockly란?</h1><p>Google이 만든 <a href="https://developers.google.com/blockly/" target="_blank" rel="noopener">Blockly</a> 라이브러리는 웹, ios, Android에서 구동하는<br>블록 기반 프로그래밍 앱을 만들기 위해 사용됩니다.</p><p>주의하실 점은 <strong>Blockly 라이브러리</strong>는 개발자를 위한 도구이며,<br>우리가 흔히 알고 있는, ‘블록을 맞추어 프로그래밍을 할 수 있게 만든 플랫폼 또는 앱’<br>은 <strong>Blockly 어플리케이션(Blockly Apps)</strong> 라고 불린다는 것입니다.</p><p>그 용도에 맞게, Blockly에서는 다양한 Default Block을 제공하며, 원한다면 얼마든지<br>자신이 원하는 모양과 기능의 블록을 만들어 사용할 수 있습니다.</p><p>또한 위에서 언급한 것처럼, Blockly 앱은 현재 웹, ios, Android 상에서 구동 가능합니다. 이 시리즈에서는 웹 페이지 또는 웹 어플리케이션에서 구동하는 Blockly App을 만드는 것을 중심으로 설명하려 합니다. 참고로, 각<br> 환경에서 Blockly 라이브러리를 사용하는 방법이 조금씩 달라지니,<br>웹 이외의 환경에서 Blockly App을 개발하시려는 분들은<a href="https://developers.google.com/blockly/guides/overview" target="_blank" rel="noopener">Blockly 공식 가이드(영문)</a> 를 참고하실 수 있습니다.<br> 사실 개발 환경이 달라져도 기본 개요는 같지만 각 플랫폼에 맞게 용어나 코딩 방법 등이 달라집니다.</p><h2 id="Blockly-지원-언어"><a href="#Blockly-지원-언어" class="headerlink" title=" Blockly 지원 언어"></a> Blockly 지원 언어</h2><p> 사용자가 보기에 Blockly가 만들어 낸 Block들은 코딩을 위해 만들어진 기초 코드 조각처럼 보이지만, 이 블록들은<br> 사실 실제 프로그래밍 언어로 된 코드가 매핑되어 있는 그래픽 요소 조각입니다.<br> Blockly 블록들은 기본적으로 <strong>Javascript</strong> 또는 <strong>JSON array</strong>로 그 형태가 만들어져 있으며, 각 블록마다 본격적인<br>고급 프로그래밍 언어로 되어 있는 코드가 매핑되어 있습니다.</p><p>Blockly 블록에 매핑할 수 있는 언어는 현재로서는 이 5가지입니다.</p><ul><li>Javascript</li><li>Python</li><li>PHP</li><li>Lua</li><li>Dart</li></ul><p>블록마다 실제 실행 가능한 코드가 정해져 있기 때문에, 자신이 조합한<br>블록을 코드로 바꾸어 바로바로 확인하거나 실행하는 것도 가능합니다. 이에 대해서는<br>다른 항목에서 서술하겠습니다.</p><h2 id="Blockly-어플리케이션-개발-과정"><a href="#Blockly-어플리케이션-개발-과정" class="headerlink" title=" Blockly 어플리케이션 개발 과정"></a> Blockly 어플리케이션 개발 과정</h2><p> Blockly 라이브러리는 개발자를 위한 라이브러리이며, 그것이 실제로 활용되기 위해서는<br> 이 라이브러리를 이용해 어플리케이션을 만들어 사용해야 합니다. 상술한 것처럼, Blockly<br> 어플리케이션은 웹, ios, Android의 3가지 플랫폼에 적용 가능합니다.</p><p>웹을 기준으로 보았을 때, Blockly Application을 만드는 기본 단계는 다음과 같습니다.</p><ol><li>웹 페이지를 만든다.</li><li>만든 웹 페이지에 Blockly editor 를 삽입한다.</li><li>필요한 custom block을 정의한다.</li><li>만든 블록에 code generator를 붙여, 블록에 실제 프로그래밍 언어로 되어 있는 코드를 매핑한다.</li><li>만든 블록을 editor에 추가한다.</li><li>나머지 필요한 기능들을 구현한다.</li></ol><h2 id="Blockly-라이브러리-다운로드-및-시작하기-Web"><a href="#Blockly-라이브러리-다운로드-및-시작하기-Web" class="headerlink" title="Blockly 라이브러리 다운로드 및 시작하기(Web)"></a>Blockly 라이브러리 다운로드 및 시작하기(Web)</h2><p>Blockly는 기본적으로 오픈소스 라이브러리입니다. <a href="https://github.com/google/blockly" target="_blank" rel="noopener">Blockly 공식 Github 레포지터리</a><br>에서 소스를 clone 해 사용할 수 있습니다. Blockly는 서버의 개입 없이 client-side 에서 작동하며, 대부분의 경우 별다른 3rd-party dependency를 필요로 하지 않기 때문에,<br>이렇게 소스코드를 다운받는 것으로 준비는 끝납니다.<br><img src="/img/fixed_demo.png" alt="screenshot"><br>Blockly 레포지터리를 제대로 clone해 오셨다면 해당 폴더의 <strong>demos/fixed/index.html</strong>을 실행하여 작동 테스트를 해 볼 수 있습니다.<br>이렇게 환경 구축을 끝내고 나면, 이제 Blockly 라이브러리를 사용해 어플리케이션을 만들 준비가 된 것입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/Cover_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Blockly란&quot;&gt;&lt;a href=&quot;#Blockly란&quot; class=&quot;headerlink&quot; title=&quot;Blockly란?&quot;&gt;&lt;/a&gt;Blockly란?&lt;/h1&gt;&lt;p&gt;G
      
    
    </summary>
    
      <category term="Blockly" scheme="https://vleudive.github.io/categories/Blockly/"/>
    
    
      <category term="google" scheme="https://vleudive.github.io/tags/google/"/>
    
      <category term="blockly" scheme="https://vleudive.github.io/tags/blockly/"/>
    
  </entry>
  
</feed>
